# Star Archive 规格驱动编程说明

本文档描述本项目中**规格驱动编程（Specification-Driven Development）**的约定、流程与落地方式，供开发与协作时统一遵循。

---

## 一、什么是规格驱动编程

在本项目中，**规格驱动编程**指：

- **先写清“做什么”和“做到什么程度”，再写代码**：需求与验收标准以规格文档形式固定，实现阶段严格对照规格。
- **规格即契约**：接口契约（API、数据模型）由规格推导或与规格同步，前后端、多服务以契约为准。
- **可追溯**：从用户故事 → 功能需求 → 技术设计 → 任务列表 → 代码/测试，每一层都可追溯到上一级规格。

目标：减少理解偏差、避免范围蔓延、便于测试与回归，并让 AI 或新成员能依据规格高效实现与评审。

---

## 二、规格的层次结构

本项目的规格自顶向下分为以下层次，上层是下层的输入与约束。

```
业务需求/用户描述
       ↓
  功能规格 (spec)
       ↓
  技术计划 (plan) + 数据模型 + 契约 (contracts)
       ↓
  任务列表 (tasks) + 检查清单 (checklists)
       ↓
  代码与测试
```

| 层次 | 载体 | 主要内容 | 读者 |
|------|------|----------|------|
| **业务需求** | 产品/需求文档、用户描述 | 业务目标、用户场景、价值 | 产品、开发、测试 |
| **功能规格** | `spec.md`（User Stories、FR、验收场景、成功标准） | 做什么、验收条件、边界与实体 | 全员 |
| **技术计划** | `plan.md`、`research.md`、`data-model.md`、`contracts/` | 技术栈、结构、数据模型、API 契约 | 开发、架构 |
| **任务与检查** | `tasks.md`、`checklists/` | 具体任务项、质量检查项 | 开发、AI Agent |
| **实现** | 后端 Controller/Service/Entity、前端 API/页面、DB Schema | 可运行系统 | 开发、测试 |

---

## 三、本项目的规格载体与位置

### 3.1 规格模板与工作流（Speckit）

- **模板目录**：`.specify/templates/`
  - `spec-template.md`：功能规格模板（含**本项目约定**：规格只写做什么与验收标准、前后端边界、基线引用）
  - `plan-template.md`：技术计划模板（含**本项目默认** Technical Context、Project Structure、Constitution Check 条款）
  - `tasks-template.md`：任务列表模板（含**本项目** backend/frontend 路径约定）
  - `checklist-template.md`：检查清单模板
- **宪法/原则**：`.specify/memory/constitution.md`（与 `.cursor/rules` 一致的项目原则、技术栈约束、分层与测试要求；规划时需通过 Constitution Check）
- **项目规格基线**：`docs/项目规格基线.md`（当前已实现模块、API 契约摘要、核心实体；新特性可引用“在 xx 模块上扩展”）
- **单特性规格目录**：`specs/[编号]-[特性短名]/`（由 `/speckit.specify` 等命令创建）
  - 例如：`specs/001-user-auth/spec.md`、`plan.md`、`tasks.md`、`contracts/`、`checklists/`

### 3.2 Cursor 命令（Speckit 工作流）

在 Cursor 中通过命令驱动“从需求到实现”的完整流程：

| 命令 | 作用 | 输入 | 输出 |
|------|------|------|------|
| `/speckit.specify` | 从自然语言描述生成/更新功能规格 | 特性描述 | `specs/…/spec.md`、需求检查清单 |
| `/speckit.clarify` | 澄清规格中的模糊点 | spec.md | 澄清后的 spec、可选问答 |
| `/speckit.plan` | 根据 spec 做技术规划与设计 | spec.md、constitution | plan.md、research.md、data-model.md、contracts/、quickstart.md |
| `/speckit.tasks` | 将计划拆解为可执行任务 | plan + spec | tasks.md（按 User Story 分阶段） |
| `/speckit.checklist` | 生成质量/安全/测试等检查清单 | 特性上下文 | checklists/*.md |
| `/speckit.implement` | 按 tasks.md 执行实现并勾选完成 | tasks.md、plan、contracts | 代码与测试、任务勾选 |

### 3.3 业务与设计文档（非 Speckit）

- **业务需求**：`docs/智能监测系统-实现方案.md`（模块划分、数据存储模型等）
- **流程说明**：如 `docs/新闻到事件流程说明.md`
- **数据模型设计**：`docs/数据模型设计.docx`、`docker/init-db/01-init-schema.sql`（库表为“数据库规格”）

---

## 四、从需求到实现的开发流程

### 4.1 标准流程（新特性从零开始）

1. **写清需求**  
   用自然语言描述“谁、在什么场景、要完成什么、达到什么效果”。

2. **生成功能规格**  
   执行 `/speckit.specify`，填写/生成：
   - User Stories（含优先级 P1/P2/P3）
   - Acceptance Scenarios（Given-When-Then）
   - Functional Requirements（FR-xxx）
   - Success Criteria（可度量、技术无关）
   - Key Entities（若涉及数据）

3. **（可选）澄清**  
   若有 `[NEEDS CLARIFICATION]` 或歧义，使用 `/speckit.clarify` 与产品/业务确认。

4. **技术计划**  
   执行 `/speckit.plan`，得到：
   - Technical Context（语言、依赖、存储、测试、平台）
   - Constitution Check
   - Project Structure（backend/frontend 等）
   - data-model.md、contracts/（API 等）、quickstart.md

5. **任务拆解**  
   执行 `/speckit.tasks`，得到按 User Story 分阶段的 tasks.md（含 [P] 并行、依赖顺序）。

6. **检查清单**  
   按需执行 `/speckit.checklist`，生成需求/安全/测试等清单，实现前或 MR 前做自检。

7. **实现**  
   执行 `/speckit.implement` 或人工按 tasks.md 逐项实现，并在 tasks 文件中将已完成项勾选为 `[x]`。

### 4.2 与现有代码库的衔接（无独立 spec 的改动）

对已有模块的小改动或 Bug 修复，可不必新建 `specs/` 下的完整规格，但建议：

- **接口变更**：在对应 Controller、DTO、前端 `api.ts` 类型上同步修改，并更新本项目的 API 清单（如 `IMPLEMENTATION_GUIDE.md` 或自维护的 API 文档）。
- **数据变更**：在 `docker/init-db/01-init-schema.sql`（或迁移脚本）中体现，并与 Entity/DTO 一致。
- **复杂逻辑**：在代码注释或 `docs/` 中简要说明“规格”（输入/输出/边界），便于后续写 spec 或单测。

---

## 五、规格与代码的对应关系

本项目采用**前后端分离 + 分层架构**，规格在各层的体现如下。

### 5.1 后端（Spring Boot）

| 规格来源 | 代码/配置体现 |
|----------|----------------|
| 功能需求（谁能做什么） | Controller 的 URL、方法、权限与注释 |
| API 契约（入参/出参） | DTO：`dto/*.java`（请求/响应结构） |
| 数据模型 | Entity：`entity/*.java`；Repository：`repository/*.java` |
| 业务规则与流程 | Service：`service/*.java` |
| 数据库结构 | `docker/init-db/01-init-schema.sql`（及迁移脚本） |

约定：

- Controller 只做参数校验与调用 Service，不写业务逻辑。
- 对外接口一律使用 DTO，不直接暴露 Entity。
- 新增/变更 API 时，同步维护 DTO 与（若有）文档中的接口清单。

### 5.2 前端（React + TypeScript）

| 规格来源 | 代码体现 |
|----------|----------|
| 页面与交互（User Story/UI） | `pages/*`、`components/*` |
| API 契约 | `services/api.ts` 中的接口定义与 TypeScript 类型（与后端 DTO 对应） |
| 状态与领域数据 | `store/slices/*`、`types/*` |

约定：

- 调用后端前，在 `api.ts` 中定义接口与类型，与后端 DTO 语义一致（字段名、可选性、分页结构等）。
- 组件尽量按“展示组件 + 容器/逻辑”划分，便于对照规格做单测或 E2E。

### 5.3 数据库

| 规格来源 | 体现 |
|----------|------|
| 数据模型设计文档、业务实体 | `docker/init-db/01-init-schema.sql` |
| 测试/演示数据 | `docker/init-db/02-test-data.sql` 等 |

约定：

- 表结构变更以 SQL 脚本为唯一权威，Entity 与 Repository 与之一致。
- 若支持多种数据库（如 Doris / MySQL），在规格或配置中明确（如系统配置中的“模型管理 Text2Sql 数据库类型”）。

### 5.4 契约的传递

- **后端 → 前端**：通过 DTO 的字段名与类型定义“契约”；本项目未使用 OpenAPI/Swagger，契约以 DTO + 接口清单/文档为准。
- **需求 → API**：功能规格中的“用户操作/查询”应映射到具体 API（在 plan 的 contracts/ 或文档中说明），实现时 Controller/Service 按此实现。

---

## 六、质量门禁与检查清单

### 6.1 规格质量（spec 阶段）

- 无实现细节（不写技术栈、具体 API 名）。
- 需求可测试、无歧义；成功标准可度量且技术无关。
- User Story 可独立验收；边界与异常在 Edge Cases 中有描述。

使用 `/speckit.specify` 生成的需求检查清单（如 `checklists/requirements.md`）用于在进入 plan 前做自检。

### 6.2 实现阶段

- 代码符合 `.cursor/rules/` 中的 Java/TypeScript/JavaScript 规范。
- 新增/变更 API：Controller、DTO、前端 api 与类型同步更新。
- 涉及持久化：Schema/迁移与 Entity 一致，必要时补充单测或集成测试。

### 6.3 完成定义（DoD）

- 与本次改动相关的 tasks 在 tasks.md 中已勾选完成。
- 若该特性有 checklists，清单项已通过或已记录例外。
- 关键路径有测试（按项目要求：单元/集成/E2E），且通过。
- 文档/接口清单已更新（若有约定）。

---

## 七、本项目目录与命令速查

### 7.1 规格与文档目录

```
.specify/
├── memory/constitution.md      # 项目原则与约束
├── templates/                  # spec / plan / tasks / checklist 模板
└── scripts/                   # 创建特性分支、规划等脚本

specs/                         # 按特性存放（由 speckit 创建）
└── [编号]-[特性短名]/
    ├── spec.md
    ├── plan.md
    ├── tasks.md
    ├── research.md
    ├── data-model.md
    ├── quickstart.md
    ├── contracts/              # API 等契约
    └── checklists/

docs/                          # 业务与设计文档
├── 智能监测系统-实现方案.md
├── 新闻到事件流程说明.md
├── 规格驱动编程说明.md        # 本文
└── ...

docker/init-db/
├── 01-init-schema.sql         # 数据库表结构规格
└── 02-test-data.sql           # 测试数据
```

### 7.2 Cursor 命令速查

- **从需求到规格**：`/speckit.specify` → 填写/生成 spec，可选 `/speckit.clarify`。
- **从规格到设计**：`/speckit.plan` → plan、data-model、contracts。
- **从设计到任务**：`/speckit.tasks` → tasks.md。
- **质量清单**：`/speckit.checklist` → checklists。
- **按任务实现**：`/speckit.implement` 或人工按 tasks.md 实现并勾选。

### 7.3 代码中“规格”的落点

- **API 契约**：后端 `controller/` + `dto/`，前端 `services/api.ts` 类型与调用。
- **数据模型**：后端 `entity/`、`repository/`，DB `docker/init-db/01-init-schema.sql`。
- **业务规则**：`service/` 与 `docs/` 中的流程说明（如新闻→事件）。

---

## 八、总结

| 原则 | 做法 |
|------|------|
| 规格先行 | 新特性先有 spec（User Stories、FR、验收标准），再 plan 与 tasks，最后实现。 |
| 契约一致 | API 以 DTO/类型为准；DB 以 Schema 脚本为准；前后端与 Schema 保持同步。 |
| 可追溯 | 从 User Story → FR → plan/contracts → tasks → 代码，层级清晰。 |
| 质量门禁 | 用 checklists 与 DoD 在规格阶段和实现阶段做自检与评审。 |
| 工具辅助 | 使用 `.specify` 模板与 `/speckit.*` 命令标准化流程，便于人与 AI 协作。 |

本文档描述的是**整体规格驱动编程的约定与流程**；具体 Java/TS 编码规范见 `.cursor/rules/`，部署与启动见 `DEPLOYMENT.md`、`START_GUIDE.md` 等。
