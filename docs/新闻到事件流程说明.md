# 新闻数据 → 事件数据 流程说明

## 一、整体流程概览

```
新闻表 (news)  →  大模型摘要  →  按日期 + 相似度聚类  →  事件表 (event) + 事件-新闻关联表 (event_news)
```

事件由**新闻聚合**生成：系统每日定时从近期新闻中抽取「事件摘要」，再按**日期 + 摘要相似度**做聚类，把多条相关新闻归为同一事件，并写入 `event` 与 `event_news` 表。

---

## 二、数据表关系

| 表名 | 说明 |
|------|------|
| **news** | 原始新闻（标题、正文、发布时间、媒体、分类等） |
| **event** | 聚合后的事件（标题、事件日期、关联新闻数、首/末发布时间等） |
| **event_news** | 事件与新闻多对多关联（event_id, news_id, publish_time） |

- 一条**新闻**可只属于一个事件（聚类时归入一个簇）。
- 一个**事件**对应多条**新闻**（一个簇里的所有新闻记入同一 event_id）。

---

## 三、核心逻辑（后端）

### 1. 入口：定时任务

- **类**：`EventExtractionScheduler`
- **方法**：`runDailyExtraction()`
- **触发**：每日 **凌晨 2 点**（Cron：`0 0 2 * * ?`，可通过配置项 `event.extraction.cron` 覆盖）
- **调用**：`EventService.runDailyExtraction()`

### 2. 事件提取流程（EventService.runDailyExtraction）

#### 步骤 1：选取候选新闻

- 时间范围：**昨日 0 点至今**（`LocalDate.now().minusDays(1).atStartOfDay()`）
- 数据源：`NewsRepository.findByPublishTimeGreaterThanEqualOrderByPublishTimeAsc(since)`
- 排除：已在任意事件中的新闻（通过 `EventNewsRepository.findAllNewsIdsInEvents()` 得到已入事件 news_id，过滤掉）

即：**只对「近期且尚未入过事件」的新闻做本次提取**。

#### 步骤 2：大模型生成事件摘要

- 对每条候选新闻调用一次大模型：
  - **方法**：`extractEventSummaryByLlm(News news, String apiKey)`
  - **请求**：系统配置中的大模型 API（与智能画像/智能问答同一套 llm_* 配置）
  - **System 提示词**：  
    `你是一个新闻事件摘要助手。根据用户提供的新闻标题和正文，用一句话（不超过50字）概括该新闻所描述的事件，仅输出这一句话，不要其他解释。`
  - **User 内容**：`标题：{新闻标题}\n正文：{正文前 2000 字}`
  - **结果**：得到该新闻的「事件摘要」一句话；失败则本条不参与后续聚类

#### 步骤 3：按日期 + 相似度聚类

- **方法**：`clusterByDateAndSimilarity` → 同日内 `clusterBySimilarity`
- **按日分组**：先按新闻的 `publish_time` 的**日期**分组（同一天的新闻在一起）。
- **同日内聚类**：
  - 将摘要切成**词集合**（2 字及以上，去标点）：`summaryWords(summary)`
  - 使用 **Jaccard 相似度**（两集合交集/并集）判断两条摘要是否属于同一事件
  - 相似度阈值：**0.25**（可视为「有一定用词重叠」即归为同一事件）
  - 流式聚类：遍历每条新闻，若与已有簇中任一条摘要相似度 ≥ 0.25 则加入该簇，否则新建簇

得到：`List<List<NewsWithSummary>>`，每个内层 List 是一个事件对应的新闻簇。

#### 步骤 4：落库事件与关联

对每个簇：

1. **生成事件 (event)**  
   - `event_id`：`evt-` + 12 位随机十六进制  
   - `title`：簇内最长的一条摘要（若仅 1 条则用该条）  
   - `event_date`：簇内新闻的发布日（取第一条的日期）  
   - `news_count`：簇大小  
   - `first_publish_time` / `last_publish_time`：簇内最早/最晚新闻发布时间  
   - `summary`：当前实现为 null  

2. **写入 event 表**：`EventRepository.save(event)`

3. **写入 event_news 表**：对簇内每条新闻插入一条 `EventNews(event_id, news_id, publish_time, created_time)`，建立事件与新闻的多对多关系

---

## 四、相关代码与配置

| 用途 | 位置 |
|------|------|
| 定时任务入口 | `backend/.../scheduler/EventExtractionScheduler.java` |
| 事件提取与聚类 | `backend/.../service/EventService.java`（`runDailyExtraction`、`extractEventSummaryByLlm`、`clusterByDateAndSimilarity`、`clusterBySimilarity`、Jaccard） |
| 事件列表/详情 API | `backend/.../controller/EventController.java`，`EventService.getEventList` / `getEventDetail` |
| 新闻查询 | `backend/.../repository/NewsRepository.java`（如 `findByPublishTimeGreaterThanEqualOrderByPublishTimeAsc`） |
| 事件与事件-新闻 | `EventRepository`、`EventNewsRepository` |
| 表结构 | `docker/init-db/01-init-schema.sql`（news、event、event_news） |
| 大模型配置 | 与系统配置 llm_* / application.yml 中 bailian 一致；未配置时跳过提取并打日志 |

---

## 五、如何手动触发一次「新闻 → 事件」

- **方式一**：调用事件提取逻辑（不经过定时器）  
  - 在应用内注入 `EventService`，调用 `eventService.runDailyExtraction();`  
  - 例如在管理接口或测试里加一个「执行一次事件提取」的接口，内部调用该方法即可。

- **方式二**：等待每日凌晨 2 点定时任务自动执行（见 `EventExtractionScheduler`）。

---

## 六、小结

- **新闻 → 事件** = 取近期未入事件的新闻 → 大模型生成每条新闻的「事件摘要」→ 按**日期**分组后再按摘要 **Jaccard 相似度 ≥ 0.25** 聚类 → 每个簇写一条 `event` 和若干条 `event_news`。
- 前端「态势感知」中的**事件聚合**列表与详情，即来自上述 `event` 与 `event_news` 的查询结果。
